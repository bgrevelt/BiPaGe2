# BiPaGe2
BiPaGe is a Binary Parser Generator. The program will generated code to parse binary structures based on definitions of those structure. It has the following features
* Data in big and little endian.
* Non-standard width integers
* <more to come>
  
The following back-ends (code generators) are available
* C++

## Using BiPaGe
BiPaGe takes in input file that contains one or more structure definitions and produces parser and generator code for those datatypes in the chosen language. 
In BiPaGe a data structure is defined in the follwing way
```
<struture name>
{
   <field name 1> : <type>;
   <field name 2> : <type>;
   etc.
}
```
For example:
```
DataFrame
{
   Preamble : uint64;
   DataField1: int32;
   DataField2: float64;
   CRC: uint32;
}
```
To generate the parser and builder code, run bipage, feeding it the input file
`python bipage.py -i <input file> -o <output director>`

BiPaGe supports the following optional command line arguments
* `--cpp-no-validate-builder-input`
When supplied, no input validation code will be generated by the c++ backend. See the 'Non-standard sized integers' section for more details.
* `--cpp-no-to-string`
When supplied, no to_string method will be generated by the c++ backend in the parser class. 

## Basic types
The following basic types are supported
* Signed integer: int8, int16, int32, int64 as well as the short hand aliases s8, s16, s32, and s64.
* Unsigned integer: uint8, uint16, uint32, uint64 as well as the short hand aliases u8, u16, u32, and u64.
* Floating point: float32, float64, f32, and f64
  
## Non-standard sized integers
BiPaGe also support non-standard sized signed and unsigned integers. These type of fields are often employed to save space, for example in streaming data protocols. 
Non standard fields have to be declared inside what we will refer to as a 'capture scope'. The capture scope is the underlying type that encompasses the non-standard sized integer types. 
```
DataFrame
{
  Preamble : uint64;
  {
    SmallSigned : int6;
    SmallUnsigned: uint6;
    Nibble: uint4;
  }
  CRC: uint32;
}
```
The capture scope is necessary to support different endiannesses; we have to know how the encoding side treated this data to be able to transform it to the platform endian. All fields in a capture scope should add up to a standard size. The fields in the capture scope in the example above add up to 16 bits (6+6+4).

### Validation
Most languages only support standard width integers. That means that the generated setter code for non-standard field in the builder class will have a wider type argument than the actual data value. This is certainly true for C++ (which is currently our only the only supported backend) where the setter for `SmallSigned` in the example above will look something like
`void SmallSigned(std::int8_t val)`. That means that the caller of that setter can supply a value that does not fit in the underlying data type. Unfortunately there is no way to have this validated at compile time. Because of that, run time validation code is generated in these setters by default. This runtime validation code generation can be disabled by supplying the `--cpp-no-validate-builder-input` command line argument. 
  
## Endianness
> :warning: **Code generated by BiPaGe should only be run on little endian platforms!**: This section is about handling data that has been encoded *on* a big endian platform and encoding data to be sent *to* a big endian platform.
 
You can define the endianness of the data structures in a file. If the endianness of the data is not defined in the input file, little endian is assumed. The endianness can be defined once at the top of the file. This endianness applies to all data structures defined in the file
```
@bigendian;

DataStructure
{
...
}
```
You can also explicitly define little endian, but it, as this is also the default, it has no real effect.
```
@litleendian;

DataStructure
{
...
}
```

Ig big endian is defined, [byte swapping](https://en.wikipedia.org/wiki/Endianness#Byte_swapping) will occur both in the parser and in the builer. E.g the parser will assume that incoming data is in big endian format and the builder will ensure that the serialized data is in big endian format.

## Namespace
You can add a namespace to the input file by adding `namespace <namespace>` at the start of the file (but after the endianness specifier if you include that as well). Nested namespaces are supported by using a dot in between the different namespaces.
```
@litleendian;
namespace Some.Awesome.Namespace;
DataStructure
{
...
}
```
Adding a namespace to the input file will instruct the compiler to put all generated code in that namespace (or whatever comes closest to a namespace in the target language).

